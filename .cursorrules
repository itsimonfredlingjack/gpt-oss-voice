# Cursor Rules for Google Home Hack / GPT-OSS Voice

## Project Context
This is a voice-first AI assistant CLI that connects Ollama (local LLM) with Google Home speakers via Chromecast. The main interface is "The Core CLI" - a Rich-based terminal UI.

## Key Commands
- `python -m cli.app` - Run the main CLI interface
- `pytest` - Run all tests
- `pytest --cov=. --cov-report=html` - Run tests with coverage
- `python speak.py "text"` - Test TTS directly
- `python brain.py` - Test AI brain directly

## Architecture
- **cli/app.py**: Main application with Rich Live, state machine, async I/O
- **cli/raw_input.py**: Custom input handler with escape sequence support
- **speak.py**: GoogleHomeSpeaker class for TTS via Chromecast
- **brain.py**: Ollama API wrapper
- **cli/state.py**: StateManager for IDLE/THINKING/TALKING/ERROR states
- **cli/avatar.py**: BrailleAvatar with depth-based coloring
- **cli/waveform.py**: Animated waveform visualization
- **cli/theme.py**: Rich themes (Midnight Tokyo default)

## Voice-First Features
- Speaking indicator in footer shows current TTS text
- Ctrl+C interrupts speaking during TALKING state
- Arrow keys move cursor for text editing
- Input validation (max 10k chars)

## Code Style
- Google Python Style Guide
- 80 char line limit
- Type hints encouraged
- snake_case for functions, PascalCase for classes
- All public functions need docstrings

## Testing
- Use pytest
- Target >80% coverage
- Test files in `tests/` directory
- Run `pytest tests/test_avatar.py` for specific tests

## Performance
- Use `deque` for history (already implemented)
- Cache cursor string slices (already implemented)
- Limit input events per frame (already implemented)
- Avoid `list()` conversions in hot paths

## Common Issues
- Escape sequences: Use non-blocking reads, state tracking in `_escape_buffer`
- Terminal cleanup: Always call `input_handler.stop()` and `console.show_cursor()`
- Rich Live: Use `screen=True` for alternate buffer
- Async: Use `run_in_executor` for blocking calls (speak, ask_brain)

## Workflow
- Follow Conductor methodology in `conductor/tracks/`
- Use CJG workflow (Conductor + Jules + Gemini) for complex features
- Mark tasks `[~]` (in progress) â†’ `[x]` (complete)
